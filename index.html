<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Church Polygons by Size</title>
<style>
  body {
    margin: 0;
    background: #f5f5f5;
  }
  svg {
    width: 100vw;
    height: 100vh;
  }
  path {
    fill: rgba(70, 130, 180, 0.45);
    stroke: #1e3a8a;
    stroke-width: 1;
  }
</style>
</head>
<body>

<svg id="svg"></svg>

<script>
async function run() {
  const geojson = await fetch("churches.geojson").then(r => r.json());

  // ---------- Geometry helpers ----------
  function area(coords) {
    let a = 0;
    for (let i = 0; i < coords.length; i++) {
      const [x1, y1] = coords[i];
      const [x2, y2] = coords[(i + 1) % coords.length];
      a += x1 * y2 - x2 * y1;
    }
    return Math.abs(a / 2);
  }

  function centroid(coords) {
    let x = 0, y = 0;
    coords.forEach(([cx, cy]) => {
      x += cx;
      y += cy;
    });
    return [x / coords.length, y / coords.length];
  }

  function normalize(coords) {
    const [cx, cy] = centroid(coords);
    return coords.map(([x, y]) => [x - cx, y - cy]);
  }

  function bounds(coords) {
    const xs = coords.map(c => c[0]);
    const ys = coords.map(c => c[1]);
    return {
      minX: Math.min(...xs),
      maxX: Math.max(...xs),
      minY: Math.min(...ys),
      maxY: Math.max(...ys),
      w: Math.max(...xs) - Math.min(...xs),
      h: Math.max(...ys) - Math.min(...ys)
    };
  }

  // ---------- Extract & compute area ----------
  geojson.features.forEach(f => {
    const poly =
      f.geometry.type === "Polygon"
        ? f.geometry.coordinates[0]
        : f.geometry.coordinates[0][0]; // simple MultiPolygon handling

    f._coords = poly;
    f._area = area(poly);
  });

  // ---------- Sort largest â†’ smallest ----------
  geojson.features.sort((a, b) => b._area - a._area);

  const svg = document.getElementById("svg");
  const width = window.innerWidth;

  const padding = 20;
  const maxSize = 140;

  let cursorX = padding;
  let cursorY = padding;
  let rowHeight = 0;

  // ---------- Draw ----------
  geojson.features.forEach(f => {
    let coords = normalize(f._coords);
    const b = bounds(coords);

    const scale = maxSize / Math.max(b.w, b.h);

    const scaled = coords.map(([x, y]) => [
      (x - b.minX) * scale,
      (y - b.minY) * scale
    ]);

    const boxWidth = b.w * scale;
    const boxHeight = b.h * scale;

    // Wrap to next row if needed
    if (cursorX + boxWidth + padding > width) {
      cursorX = padding;
      cursorY += rowHeight + padding;
      rowHeight = 0;
    }

    const d = scaled
      .map((c, i) => {
        const x = c[0] + cursorX;
        const y = c[1] + cursorY;
        return `${i === 0 ? "M" : "L"} ${x} ${y}`;
      })
      .join(" ") + " Z";

    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", d);
    svg.appendChild(path);

    cursorX += boxWidth + padding;
    rowHeight = Math.max(rowHeight, boxHeight);
  });
}

run();
</script>

</body>
</html>
