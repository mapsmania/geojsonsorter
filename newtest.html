<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>London Churches — Shape Comparison</title>
<style>
  body {
    margin: 0;
    background: white;
  }

  svg {
    width: 100vw;
    height: auto;
    display: block;
    background: white;
  }

  .card {
    fill: white;
    stroke: #111;
    stroke-width: 1;
  }

  path {
    fill: rgba(0,0,0,0.04);
    stroke: black;
    stroke-width: 1;
  }

  .label-band {
    fill: rgba(0,0,0,0.04);
  }

  .label-text {
    fill: white;
    font-family: system-ui, -apple-system, BlinkMacSystemFont,
                 "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    font-size: 12.5px;
    font-weight: 500;
    letter-spacing: 0.02em;
    pointer-events: none;
  }
</style>
</head>
<body>

<svg id="svg"></svg>

<script>
async function run() {
  const geojson = await fetch("churches.geojson").then(r => r.json());

  // ---------- geometry helpers ----------
  function area(coords) {
    let a = 0;
    for (let i = 0; i < coords.length; i++) {
      const [x1, y1] = coords[i];
      const [x2, y2] = coords[(i + 1) % coords.length];
      a += x1 * y2 - x2 * y1;
    }
    return Math.abs(a / 2);
  }

  function centroid(coords) {
    let x = 0, y = 0;
    coords.forEach(([cx, cy]) => { x += cx; y += cy; });
    return [x / coords.length, y / coords.length];
  }

  function normalize(coords) {
    const [cx, cy] = centroid(coords);
    return coords.map(([x, y]) => [x - cx, y - cy]);
  }

  function bounds(coords) {
    const xs = coords.map(c => c[0]);
    const ys = coords.map(c => c[1]);
    return {
      minX: Math.min(...xs),
      maxX: Math.max(...xs),
      minY: Math.min(...ys),
      maxY: Math.max(...ys),
      w: Math.max(...xs) - Math.min(...xs),
      h: Math.max(...ys) - Math.min(...ys)
    };
  }

  // ---------- extract polygons ----------
  geojson.features.forEach(f => {
    const poly =
      f.geometry.type === "Polygon"
        ? f.geometry.coordinates[0]
        : f.geometry.coordinates[0][0];
    f._coords = poly;
    f._area = area(poly);
  });

  // ---------- sort largest → smallest ----------
  geojson.features.sort((a, b) => b._area - a._area);

  const svg = document.getElementById("svg");
  const screenWidth = window.innerWidth;

  // ---------- layout parameters ----------
  const padding = 32;
  const cardGap = 32;
  const cardsPerRow = 4;

  const innerPadding = 16;
  const labelBandHeight = 28;

  const cardWidth =
    (screenWidth - padding * 2 - cardGap * (cardsPerRow - 1)) / cardsPerRow;

  // ---------- global scale ----------
  const maxDimension = Math.max(
    ...geojson.features.map(f => {
      const b = bounds(f._coords);
      return Math.max(b.w, b.h);
    })
  );

  const maxPolySize = cardWidth * 0.75;
  const globalScale = maxPolySize / maxDimension;

  let cursorY = padding;
  let maxY = 0;

  // ---------- draw rows ----------
  for (let row = 0; row < Math.ceil(geojson.features.length / cardsPerRow); row++) {
    const start = row * cardsPerRow;
    const end = Math.min(start + cardsPerRow, geojson.features.length);
    const rowFeatures = geojson.features.slice(start, end);

    // tallest polygon in this row
    const firstBounds = bounds(normalize(rowFeatures[0]._coords));
    const maxRowPolyHeight = firstBounds.h * globalScale;

    const cardHeight =
      innerPadding +
      maxRowPolyHeight +
      innerPadding +
      labelBandHeight;

    const rowCenterY =
      cursorY + innerPadding + maxRowPolyHeight / 2;

    rowFeatures.forEach((f, col) => {
      const cursorX = padding + col * (cardWidth + cardGap);

      // ----- card -----
      const card = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      card.setAttribute("x", cursorX);
      card.setAttribute("y", cursorY);
      card.setAttribute("width", cardWidth);
      card.setAttribute("height", cardHeight);
      card.setAttribute("class", "card");
      svg.appendChild(card);

      // ----- polygon -----
      const coords = normalize(f._coords);
      const b = bounds(coords);

      const polyWidth = b.w * globalScale;
      const polyHeight = b.h * globalScale;

      const offsetX =
        cursorX +
        innerPadding +
        (cardWidth - innerPadding * 2 - polyWidth) / 2;

      const offsetY = rowCenterY - polyHeight / 2;

      const scaled = coords.map(([x, y]) => [
        (x - b.minX) * globalScale + offsetX,
        (y - b.minY) * globalScale + offsetY
      ]);

      const d =
        scaled.map((c, i) => `${i === 0 ? "M" : "L"} ${c[0]} ${c[1]}`).join(" ") +
        " Z";

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", d);
      svg.appendChild(path);

      // ----- label band -----
      const bandY = cursorY + cardHeight - labelBandHeight;

      const band = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      band.setAttribute("x", cursorX);
      band.setAttribute("y", bandY);
      band.setAttribute("width", cardWidth);
      band.setAttribute("height", labelBandHeight);
      band.setAttribute("class", "label-band");
      svg.appendChild(band);

      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", cursorX + cardWidth / 2);
      text.setAttribute("y", bandY + labelBandHeight / 2 + 4);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("class", "label-text");
      text.textContent = f.properties?.name ?? "Unnamed";
      svg.appendChild(text);
    });

    cursorY += cardHeight + cardGap;
    maxY = cursorY + padding;
  }

  svg.setAttribute("height", maxY);
}

run();
</script>

</body>
</html>
